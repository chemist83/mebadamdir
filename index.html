<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>40 Element Model - Large Nucleus</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #0a0a0a, #000); font-family: sans-serif; }
        #ui { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.95); color: #00ffcc; padding: 20px 40px; 
            border-radius: 40px; border: 1px solid #00ffcc; text-align: center;
            width: 500px; box-shadow: 0 0 30px rgba(0, 255, 204, 0.3);
        }
        input { width: 100%; cursor: pointer; accent-color: #00ffcc; }
        #config { font-family: 'Courier New', monospace; color: #fff; margin: 5px 0; font-size: 1.1em; }
        .spin-note { font-size: 10px; color: #ffaa00; text-transform: uppercase; letter-spacing: 1px; }
    </style>
</head>
<body>

<div id="ui">
    <div id="name" style="font-weight:bold; font-size:1.6em; letter-spacing:2px;">HYDROGEN</div>
    <div id="config">1s¹</div>
    <input type="range" id="selector" min="1" max="40" value="1">
    <div class="spin-note">Nucleus Scaled Up | Elements 1-40</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(15, 15, 45);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const atomGroup = new THREE.Group();
    scene.add(atomGroup);

    let electrons = [];
    const elements = [
        "Hydrogen","Helium","Lithium","Beryllium","Boron","Carbon","Nitrogen","Oxygen","Fluorine","Neon",
        "Sodium","Magnesium","Aluminum","Silicon","Phosphorus","Sulfur","Chlorine","Argon","Potassium","Calcium",
        "Scandium","Titanium","Vanadium","Chromium","Manganese","Iron","Cobalt","Nickel","Copper","Zinc",
        "Gallium","Germanium","Arsenic","Selenium","Bromine","Krypton","Rubidium","Strontium","Yttrium","Zirconium"
    ];

    const configs = [
        "1s¹","1s²","[He] 2s¹","[He] 2s²","[He] 2s² 2p¹","[He] 2s² 2p²","[He] 2s² 2p³","[He] 2s² 2p⁴","[He] 2s² 2p⁵","[He] 2s² 2p⁶",
        "[Ne] 3s¹","[Ne] 3s²","[Ne] 3s² 3p¹","[Ne] 3s² 3p²","[Ne] 3s² 3p³","[Ne] 3s² 3p⁴","[Ne] 3s² 3p⁵","[Ne] 3s² 3p⁶","[Ar] 4s¹","[Ar] 4s²",
        "[Ar] 3d¹ 4s²","[Ar] 3d² 4s²","[Ar] 3d³ 4s²","[Ar] 3d⁵ 4s¹","[Ar] 3d⁵ 4s²","[Ar] 3d⁶ 4s²","[Ar] 3d⁷ 4s²","[Ar] 3d⁸ 4s²","[Ar] 3d¹⁰ 4s¹","[Ar] 3d¹⁰ 4s²",
        "[Ar] 3d¹⁰ 4s² 4p¹","[Ar] 3d¹⁰ 4s² 4p²","[Ar] 3d¹⁰ 4s² 4p³","[Ar] 3d¹⁰ 4s² 4p⁴","[Ar] 3d¹⁰ 4s² 4p⁵","[Ar] 3d¹⁰ 4s² 4p⁶",
        "[Kr] 5s¹","[Kr] 5s²","[Kr] 4d¹ 5s²","[Kr] 4d² 5s²"
    ];

    function createOrbitalLobe(radius, color, type) {
        const group = new THREE.Group();
        const scaleHeight = type === 'p' ? 2.4 : 1.8;
        const lobeGeo = new THREE.SphereGeometry(radius*0.3, 20, 20);
        lobeGeo.scale(1, scaleHeight, 1);
        const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.08 });
        
        const t = new THREE.Mesh(lobeGeo, mat); t.position.y = radius * 0.5;
        const b = new THREE.Mesh(lobeGeo, mat); b.position.y = -radius * 0.5;
        group.add(t, b);
        return group;
    }

    function buildAtom(z) {
        while(atomGroup.children.length > 0) atomGroup.remove(atomGroup.children[0]);
        electrons.forEach(el => scene.remove(el.mesh));
        electrons = [];

        // ENLARGED NUCLEUS
        const nucGeo = new THREE.SphereGeometry(1.2, 32, 32);
        const nucMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0.5
        });
        const nuc = new THREE.Mesh(nucGeo, nucMat);
        atomGroup.add(nuc);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const addS = (r, col) => {
            atomGroup.add(new THREE.Mesh(new THREE.SphereGeometry(r, 64, 64), new THREE.MeshBasicMaterial({color: col, wireframe: true, transparent: true, opacity: 0.04})));
        };

        for(let i=0; i<z; i++) {
            const el = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), new THREE.MeshBasicMaterial({color: 0xffffff}));
            scene.add(el);
            const isPair = (i % 2 === 1);
            let conf = { mesh: el, angle: isPair ? Math.PI : 0, speed: (0.02 + Math.random()*0.05) * (isPair ? -1 : 1) };

            if (i < 2) { conf.type='s'; conf.radius=3; if(i===0) addS(3, 0x00ffff); } // Increased inner radius to avoid nucleus overlap
            else if (i < 4) { conf.type='s'; conf.radius=5; if(i===2) addS(5, 0xff00ff); }
            else if (i < 10) { conf.type='p'; conf.radius=4.5; conf.axIdx=(i-4)%3; if(i===4) { 
                const px=createOrbitalLobe(4.5, 0xffff00,'p'); px.rotation.z=Math.PI/2; atomGroup.add(px);
                const py=createOrbitalLobe(4.5, 0xffff00,'p'); atomGroup.add(py);
                const pz=createOrbitalLobe(4.5, 0xffff00,'p'); pz.rotation.x=Math.PI/2; atomGroup.add(pz);
            }}
            else if (i < 12) { conf.type='s'; conf.radius=7.5; if(i===10) addS(7.5, 0x00ff00); }
            else if (i < 18) { conf.type='p'; conf.radius=7; conf.axIdx=(i-12)%3; if(i===12) {
                const px=createOrbitalLobe(7, 0x00ff00,'p'); px.rotation.z=Math.PI/2; atomGroup.add(px);
                const py=createOrbitalLobe(7, 0x00ff00,'p'); atomGroup.add(py);
                const pz=createOrbitalLobe(7, 0x00ff00,'p'); pz.rotation.x=Math.PI/2; atomGroup.add(pz);
            }}
            else if (i < 20) { conf.type='s'; conf.radius=10.5; if(i===18) addS(10.5, 0xffffff); }
            else if (i < 30) { conf.type='d'; conf.radius=9; conf.axIdx=(i-20)%5; 
                if(i===20) addS(9, 0xffaa00);
            }
            else if (i < 36) { conf.type='p'; conf.radius=13; conf.axIdx=(i-30)%3;
                if(i===30) addS(13, 0x5555ff);
            }
            else if (i < 38) { conf.type='s'; conf.radius=16; if(i===36) addS(16, 0xff0000); } 
            else { conf.type='d'; conf.radius=14.5; conf.axIdx=(i-38)%5;
                if(i===38) addS(14.5, 0xff5500);
            }
            
            electrons.push(conf);
        }

        document.getElementById('name').innerText = elements[z-1].toUpperCase();
        document.getElementById('config').innerText = configs[z-1];
    }

    buildAtom(1);
    document.getElementById('selector').oninput = (e) => buildAtom(parseInt(e.target.value));

    function animate() {
        requestAnimationFrame(animate);
        const globalRot = 0.002; // Restored slight orbital spin for better 3D depth
        
        electrons.forEach(el => {
            el.angle += el.speed;
            const r = el.radius;
            if(el.type==='s') {
                el.mesh.position.set(Math.cos(el.angle)*r, Math.sin(el.angle)*r, 0);
            } else if(el.type==='p') {
                const path = Math.sin(el.angle)*r, drift = Math.cos(el.angle)*0.5;
                if(el.axIdx===0) el.mesh.position.set(path, drift, drift);
                else if(el.axIdx===1) el.mesh.position.set(drift, path, drift);
                else el.mesh.position.set(drift, drift, path);
            } else {
                const path = Math.cos(el.angle)*r;
                const height = Math.sin(el.angle)*r;
                el.mesh.position.set(path, height * 0.5, Math.sin(el.angle*2) * (r*0.3));
            }
            el.mesh.position.applyAxisAngle(new THREE.Vector3(0,1,0), globalRot);
        });
        
        atomGroup.rotation.y += globalRot;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
