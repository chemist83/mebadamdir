<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic 3D Circuit</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 20px; border-radius: 12px; border: 1px solid #444; pointer-events: none; }
        .btn-container { pointer-events: auto; margin-top: 10px; }
        button { background: #444; color: white; border: none; padding: 10px; cursor: pointer; border-radius: 5px; width: 100%; }
        button.active { background: #28a745; }
        .label { font-size: 12px; color: #aaa; margin-bottom: 5px; }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-weight: bold; font-size: 18px;">⚡ Pro Circuit Lab</div>
    <div class="label">Drag parts to move • Click switch to toggle</div>
    <div class="btn-container">
        <button id="wireBtn">Mode: Move Parts</button>
    </div>
    <div id="status" style="margin-top:10px; color: #ffcc00;">Status: Open Circuit</div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { DragControls } from 'three/addons/controls/DragControls.js';

    // SCENE SETUP
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 15);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // LIGHTING
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(5, 10, 5);
    scene.add(sun);

    const grid = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
    scene.add(grid);

    const components = [];
    const wires = [];
    const electrons = [];
    let wireMode = false;
    let firstPart = null;
    let switchOn = false;

    // --- MODEL BUILDERS ---

    function createBattery(x, z) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2), new THREE.MeshStandardMaterial({color: 0x222222}));
        body.rotation.z = Math.PI/2;
        const copper = new THREE.Mesh(new THREE.CylinderGeometry(0.51, 0.51, 0.6), new THREE.MeshStandardMaterial({color: 0xb87333}));
        copper.rotation.z = Math.PI/2; copper.position.x = 0.7;
        const tip = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.2), new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
        tip.rotation.z = Math.PI/2; tip.position.x = 1.1;
        group.add(body, copper, tip);
        group.position.set(x, 0.5, z);
        group.userData.type = "battery";
        return group;
    }

    function createBulb(x, z) {
        const group = new THREE.Group();
        // Holder
        const holder = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.2, 16, 32), new THREE.MeshStandardMaterial({color: 0x777777}));
        holder.rotation.x = Math.PI/2;
        // Glass
        const glass = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 32), new THREE.MeshStandardMaterial({color: 0xffffff, transparent: true, opacity: 0.3}));
        glass.position.y = 0.8;
        // Filament
        const fil = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({color: 0x333300}));
        fil.position.y = 0.8;
        const light = new THREE.PointLight(0xffff00, 0, 10);
        light.position.y = 0.8;
        group.add(holder, glass, fil, light);
        group.position.set(x, 0.2, z);
        group.userData = { type: "bulb", light: light, fil: fil };
        return group;
    }

    function createSwitch(x, z) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), new THREE.MeshStandardMaterial({color: 0x333333}));
        const leverGroup = new THREE.Group();
        const lever = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.1), new THREE.MeshStandardMaterial({color: 0xcccccc}));
        lever.position.y = 0.6;
        leverGroup.add(lever);
        group.add(base, leverGroup);
        group.position.set(x, 0.1, z);
        group.userData = { type: "switch", lever: leverGroup };
        return group;
    }

    const bat = createBattery(-5, 0);
    const bul = createBulb(0, 0);
    const swi = createSwitch(5, 0);
    [bat, bul, swi].forEach(p => { scene.add(p); components.push(p); });

    // --- LOGIC ---

    const drag = new DragControls(components, camera, renderer.domElement);
    drag.addEventListener('dragend', () => updateWires());

    document.getElementById('wireBtn').onclick = (e) => {
        wireMode = !wireMode;
        e.target.textContent = wireMode ? "Mode: Connect Wires" : "Mode: Move Parts";
        e.target.classList.toggle('active');
        firstPart = null;
    };

    window.addEventListener('click', (event) => {
        const mouse = new THREE.Vector2((event.clientX/window.innerWidth)*2-1, -(event.clientY/window.innerHeight)*2+1);
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const hits = ray.intersectObjects(components, true);

        if (hits.length > 0) {
            let obj = hits[0].object;
            while(obj.parent !== scene) obj = obj.parent;

            if (wireMode) {
                if (!firstPart) firstPart = obj;
                else if (firstPart !== obj) {
                    addWire(firstPart, obj);
                    firstPart = null;
                }
            } else if (obj.userData.type === "switch") {
                switchOn = !switchOn;
                obj.userData.lever.rotation.z = switchOn ? -0.8 : 0;
            }
        }
    });

    function addWire(a, b) {
        const curve = new THREE.LineCurve3(a.position, b.position);
        const geo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
        const mat = new THREE.MeshStandardMaterial({ color: 0x0066ff });
        const wire = new THREE.Mesh(geo, mat);
        wire.userData = { from: a, to: b };
        scene.add(wire);
        wires.push(wire);
    }

    function updateWires() {
        wires.forEach(w => {
            w.geometry.dispose();
            w.geometry = new THREE.TubeGeometry(new THREE.LineCurve3(w.userData.from.position, w.userData.to.position), 20, 0.08, 8, false);
        });
    }

    // --- LOOP ---
    let t = 0;
    function animate() {
        requestAnimationFrame(animate);
        t += 0.02;

        const isComplete = wires.length >= 3 && switchOn;
        
        // Update Bulb Visuals
        bul.userData.light.intensity = isComplete ? 50 : 0;
        bul.userData.fil.material.emissive.setHex(isComplete ? 0xffff00 : 0x000000);
        document.getElementById('status').textContent = isComplete ? "Status: Flowing ⚡" : (switchOn ? "Status: Incomplete Circuit" : "Status: Switch OFF");
        document.getElementById('status').style.color = isComplete ? "#00ff00" : "#ffcc00";

        // Electrons
        if (isComplete && Math.random() > 0.8) {
            wires.forEach(w => {
                const el = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                scene.add(el);
                electrons.push({ mesh: el, wire: w, p: 0 });
            });
        }

        for (let i = electrons.length - 1; i >= 0; i--) {
            const e = electrons[i];
            e.p += 0.03;
            e.mesh.position.lerpVectors(e.wire.userData.from.position, e.wire.userData.to.position, e.p);
            e.mesh.position.y += 0.2; // float above wire
            if (e.p >= 1) { scene.remove(e.mesh); electrons.splice(i, 1); }
        }

        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
